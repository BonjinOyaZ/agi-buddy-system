"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sqlAgentAgentExecute = void 0;
const n8n_workflow_1 = require("n8n-workflow");
const sql_db_1 = require("langchain/sql_db");
const sql_1 = require("langchain/agents/toolkits/sql");
const sqlite_1 = require("./other/handlers/sqlite");
const postgres_1 = require("./other/handlers/postgres");
const prompts_1 = require("./other/prompts");
const mysql_1 = require("./other/handlers/mysql");
const parseTablesString = (tablesString) => tablesString
    .split(',')
    .map((table) => table.trim())
    .filter((table) => table.length > 0);
async function sqlAgentAgentExecute() {
    var _a, _b, _c, _d, _e;
    this.logger.verbose('Executing SQL Agent');
    const model = (await this.getInputConnectionData("ai_languageModel", 0));
    const items = this.getInputData();
    const returnData = [];
    for (let i = 0; i < items.length; i++) {
        const item = items[i];
        const input = this.getNodeParameter('input', i);
        if (input === undefined) {
            throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'No value for the required parameter "Prompt" was returned.');
        }
        const options = this.getNodeParameter('options', i, {});
        const selectedDataSource = this.getNodeParameter('dataSource', i, 'sqlite');
        const includedSampleRows = options.includedSampleRows;
        const includedTablesArray = parseTablesString((_a = options.includedTables) !== null && _a !== void 0 ? _a : '');
        const ignoredTablesArray = parseTablesString((_b = options.ignoredTables) !== null && _b !== void 0 ? _b : '');
        let dataSource = null;
        if (selectedDataSource === 'sqlite') {
            if (!item.binary) {
                throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'No binary data found, please connect a binary to the input if you want to use SQLite as data source');
            }
            dataSource = sqlite_1.getSqliteDataSource.call(this, item.binary);
        }
        if (selectedDataSource === 'postgres') {
            dataSource = await postgres_1.getPostgresDataSource.call(this);
        }
        if (selectedDataSource === 'mysql') {
            dataSource = await mysql_1.getMysqlDataSource.call(this);
        }
        if (!dataSource) {
            throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'No data source found, please configure data source');
        }
        const agentOptions = {
            topK: (_c = options.topK) !== null && _c !== void 0 ? _c : 10,
            prefix: (_d = options.prefixPrompt) !== null && _d !== void 0 ? _d : prompts_1.SQL_PREFIX,
            suffix: (_e = options.suffixPrompt) !== null && _e !== void 0 ? _e : prompts_1.SQL_SUFFIX,
        };
        const dbInstance = await sql_db_1.SqlDatabase.fromDataSourceParams({
            appDataSource: dataSource,
            includesTables: includedTablesArray.length > 0 ? includedTablesArray : undefined,
            ignoreTables: ignoredTablesArray.length > 0 ? ignoredTablesArray : undefined,
            sampleRowsInTableInfo: includedSampleRows !== null && includedSampleRows !== void 0 ? includedSampleRows : 3,
        });
        const toolkit = new sql_1.SqlToolkit(dbInstance, model);
        const agentExecutor = (0, sql_1.createSqlAgent)(model, toolkit, agentOptions);
        const response = await agentExecutor.call({ input });
        returnData.push({ json: response });
    }
    return this.prepareOutputData(returnData);
}
exports.sqlAgentAgentExecute = sqlAgentAgentExecute;
//# sourceMappingURL=execute.js.map