"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OutputParserStructured = void 0;
const n8n_workflow_1 = require("n8n-workflow");
const json_schema_to_zod_1 = require("json-schema-to-zod");
const zod_1 = require("zod");
const output_parsers_1 = require("langchain/output_parsers");
const output_parser_1 = require("langchain/schema/output_parser");
const get_1 = __importDefault(require("lodash/get"));
const logWrapper_1 = require("../../../utils/logWrapper");
const STRUCTURED_OUTPUT_KEY = '__structured__output';
const STRUCTURED_OUTPUT_OBJECT_KEY = '__structured__output__object';
const STRUCTURED_OUTPUT_ARRAY_KEY = '__structured__output__array';
class N8nStructuredOutputParser extends output_parsers_1.StructuredOutputParser {
    async parse(text) {
        var _a, _b, _c;
        try {
            const parsed = (await super.parse(text));
            return ((_c = (_b = (_a = (0, get_1.default)(parsed, `${STRUCTURED_OUTPUT_KEY}.${STRUCTURED_OUTPUT_OBJECT_KEY}`)) !== null && _a !== void 0 ? _a : (0, get_1.default)(parsed, `${STRUCTURED_OUTPUT_KEY}.${STRUCTURED_OUTPUT_ARRAY_KEY}`)) !== null && _b !== void 0 ? _b : (0, get_1.default)(parsed, STRUCTURED_OUTPUT_KEY)) !== null && _c !== void 0 ? _c : parsed);
        }
        catch (e) {
            throw new output_parser_1.OutputParserException(`Failed to parse. Text: "${text}". Error: ${e}`, text);
        }
    }
    static fromZedJsonSchema(schema) {
        const { description, ...restOfSchema } = schema;
        const zodSchemaString = (0, json_schema_to_zod_1.parseSchema)(restOfSchema);
        const itemSchema = new Function('z', `return (${zodSchemaString})`)(zod_1.z);
        const returnSchema = zod_1.z.object({
            [STRUCTURED_OUTPUT_KEY]: zod_1.z
                .object({
                [STRUCTURED_OUTPUT_OBJECT_KEY]: itemSchema.optional(),
                [STRUCTURED_OUTPUT_ARRAY_KEY]: zod_1.z.array(itemSchema).optional(),
            })
                .describe(`Wrapper around the output data. It can only contain ${STRUCTURED_OUTPUT_OBJECT_KEY} or ${STRUCTURED_OUTPUT_ARRAY_KEY} but never both.`)
                .refine((data) => {
                return (Boolean(data[STRUCTURED_OUTPUT_OBJECT_KEY]) !==
                    Boolean(data[STRUCTURED_OUTPUT_ARRAY_KEY]));
            }, {
                message: 'One and only one of __structured__output__object and __structured__output__array should be present.',
                path: [STRUCTURED_OUTPUT_KEY],
            }),
        });
        return N8nStructuredOutputParser.fromZodSchema(returnSchema);
    }
}
class OutputParserStructured {
    constructor() {
        this.description = {
            displayName: 'Structured Output Parser',
            name: 'outputParserStructured',
            icon: 'fa:code',
            group: ['transform'],
            version: 1,
            description: 'Return data in a defined JSON format',
            defaults: {
                name: 'Structured Output Parser',
            },
            codex: {
                alias: ['json', 'zod'],
                categories: ['AI'],
                subcategories: {
                    AI: ['Output Parsers'],
                },
                resources: {
                    primaryDocumentation: [
                        {
                            url: 'https://docs.n8n.io/integrations/builtin/cluster-nodes/sub-nodes/n8n-nodes-langchain.outputparserstructured/',
                        },
                    ],
                },
            },
            inputs: [],
            outputs: ["ai_outputParser"],
            outputNames: ['Output Parser'],
            properties: [
                {
                    displayName: 'JSON Schema',
                    name: 'jsonSchema',
                    type: 'json',
                    description: 'JSON Schema to structure and validate the output against',
                    default: `{
  "type": "object",
  "properties": {
    "state": {
      "type": "string"
    },
    "cities": {
      "type": "array",
      "items": {
        "type": "string"
      }
    }
  }
}`,
                    typeOptions: {
                        rows: 10,
                        editor: 'json',
                        editorLanguage: 'json',
                    },
                    required: true,
                },
                {
                    displayName: 'The schema has to be defined in the <a target="_blank" href="https://json-schema.org/">JSON Schema</a> format. Look at <a target="_blank" href="https://json-schema.org/learn/miscellaneous-examples.html">this</a> page for examples.',
                    name: 'notice',
                    type: 'notice',
                    default: '',
                },
            ],
        };
    }
    async supplyData(itemIndex) {
        const schema = this.getNodeParameter('jsonSchema', itemIndex);
        let itemSchema;
        try {
            itemSchema = (0, n8n_workflow_1.jsonParse)(schema);
        }
        catch (error) {
            throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'Error during parsing of JSON Schema.');
        }
        const parser = N8nStructuredOutputParser.fromZedJsonSchema(itemSchema);
        return {
            response: (0, logWrapper_1.logWrapper)(parser, this),
        };
    }
}
exports.OutputParserStructured = OutputParserStructured;
//# sourceMappingURL=OutputParserStructured.node.js.map