"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.N8nJsonLoader = void 0;
const json_1 = require("langchain/document_loaders/fs/json");
const helpers_1 = require("./helpers");
class N8nJsonLoader {
    constructor(context) {
        this.context = context;
    }
    async processAll(items) {
        const docs = [];
        if (!items)
            return [];
        for (let itemIndex = 0; itemIndex < items.length; itemIndex++) {
            const processedDocuments = await this.processItem(items[itemIndex], itemIndex);
            docs.push(...processedDocuments);
        }
        return docs;
    }
    async processItem(item, itemIndex) {
        var _a;
        const pointers = this.context.getNodeParameter('pointers', itemIndex);
        const pointersArray = pointers.split(',').map((pointer) => pointer.trim());
        const textSplitter = (await this.context.getInputConnectionData("ai_textSplitter", 0));
        const metadata = (_a = (0, helpers_1.getMetadataFiltersValues)(this.context, itemIndex)) !== null && _a !== void 0 ? _a : [];
        if (!item)
            return [];
        const itemString = JSON.stringify(item.json);
        const itemBlob = new Blob([itemString], { type: 'application/json' });
        const jsonDoc = new json_1.JSONLoader(itemBlob, pointersArray);
        const docs = textSplitter ? await jsonDoc.loadAndSplit(textSplitter) : await jsonDoc.load();
        if (metadata) {
            docs.forEach((document) => {
                document.metadata = {
                    ...document.metadata,
                    ...metadata,
                };
            });
        }
        return docs;
    }
}
exports.N8nJsonLoader = N8nJsonLoader;
//# sourceMappingURL=N8nJsonLoader.js.map