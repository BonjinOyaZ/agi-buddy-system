"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.N8nEPubLoader = void 0;
const epub_parser_1 = require("@gxl/epub-parser");
const base_1 = require("langchain/document_loaders/base");
const document_1 = require("langchain/document");
const html_to_text_1 = require("html-to-text");
class N8nEPubLoader extends base_1.BaseDocumentLoader {
    constructor(file, { splitChapters = true } = {}) {
        super();
        this.file = file;
        this.splitChapters = splitChapters;
    }
    async parse(epub) {
        var _a;
        const parsed = await epub;
        const chapters = await Promise.all(((_a = parsed.sections) !== null && _a !== void 0 ? _a : []).map(async (chapter) => {
            if (!chapter.id)
                return null;
            const html = chapter.htmlString;
            if (!html)
                return null;
            return {
                html,
                title: chapter.id,
            };
        }));
        return chapters.filter(Boolean).map((chapter) => ({
            pageContent: (0, html_to_text_1.htmlToText)(chapter.html),
            metadata: {
                ...(chapter.title && { chapter: chapter.title }),
            },
        }));
    }
    async load() {
        const epub = (0, epub_parser_1.parseEpub)(this.file, { type: 'buffer' });
        const parsed = await this.parse(epub);
        return this.splitChapters
            ? parsed.map((chapter) => new document_1.Document({
                pageContent: chapter.pageContent,
                metadata: {
                    ...chapter.metadata,
                },
            }))
            : [
                new document_1.Document({
                    pageContent: parsed.map((chapter) => chapter.pageContent).join('\n\n'),
                }),
            ];
    }
}
exports.N8nEPubLoader = N8nEPubLoader;
//# sourceMappingURL=EpubLoader.js.map