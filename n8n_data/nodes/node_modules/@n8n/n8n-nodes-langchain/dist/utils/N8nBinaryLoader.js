"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.N8nBinaryLoader = void 0;
const n8n_workflow_1 = require("n8n-workflow");
const csv_1 = require("langchain/document_loaders/fs/csv");
const docx_1 = require("langchain/document_loaders/fs/docx");
const json_1 = require("langchain/document_loaders/fs/json");
const pdf_1 = require("langchain/document_loaders/fs/pdf");
const text_1 = require("langchain/document_loaders/fs/text");
const EpubLoader_1 = require("./EpubLoader");
const helpers_1 = require("./helpers");
const SUPPORTED_MIME_TYPES = {
    pdfLoader: ['application/pdf'],
    csvLoader: ['text/csv'],
    epubLoader: ['application/epub+zip'],
    docxLoader: ['application/vnd.openxmlformats-officedocument.wordprocessingml.document'],
    textLoader: ['text/plain'],
    jsonLoader: ['application/json'],
};
class N8nBinaryLoader {
    constructor(context) {
        this.context = context;
    }
    async processAll(items) {
        const docs = [];
        if (!items)
            return [];
        for (let itemIndex = 0; itemIndex < items.length; itemIndex++) {
            const processedDocuments = await this.processItem(items[itemIndex], itemIndex);
            docs.push(...processedDocuments);
        }
        return docs;
    }
    async processItem(item, itemIndex) {
        var _a;
        const selectedLoader = this.context.getNodeParameter('loader', itemIndex);
        const binaryDataKey = this.context.getNodeParameter('binaryDataKey', itemIndex);
        const docs = [];
        const metadata = (0, helpers_1.getMetadataFiltersValues)(this.context, itemIndex);
        if (!item)
            return [];
        const binaryData = (_a = item.binary) === null || _a === void 0 ? void 0 : _a[binaryDataKey];
        if (!binaryData) {
            throw new n8n_workflow_1.NodeOperationError(this.context.getNode(), 'No binary data set.');
        }
        const { mimeType } = binaryData;
        if (!SUPPORTED_MIME_TYPES[selectedLoader].includes(mimeType)) {
            const neededLoader = Object.keys(SUPPORTED_MIME_TYPES).find((loader) => SUPPORTED_MIME_TYPES[loader].includes(mimeType));
            throw new n8n_workflow_1.NodeOperationError(this.context.getNode(), `Mime type doesn't match selected loader. Please select under "Loader Type": ${neededLoader}`);
        }
        if (!Object.values(SUPPORTED_MIME_TYPES).flat().includes(mimeType)) {
            throw new n8n_workflow_1.NodeOperationError(this.context.getNode(), `Unsupported mime type: ${mimeType}`);
        }
        if (!SUPPORTED_MIME_TYPES[selectedLoader].includes(mimeType) &&
            selectedLoader !== 'textLoader') {
            throw new n8n_workflow_1.NodeOperationError(this.context.getNode(), `Unsupported mime type: ${mimeType} for selected loader: ${selectedLoader}`);
        }
        const bufferData = await this.context.helpers.getBinaryDataBuffer(itemIndex, binaryDataKey);
        const itemBlob = new Blob([new Uint8Array(bufferData)], { type: mimeType });
        let loader;
        switch (mimeType) {
            case 'application/pdf':
                const splitPages = this.context.getNodeParameter('splitPages', itemIndex);
                loader = new pdf_1.PDFLoader(itemBlob, {
                    splitPages,
                });
                break;
            case 'text/csv':
                const column = this.context.getNodeParameter('column', itemIndex);
                const separator = this.context.getNodeParameter('separator', itemIndex);
                loader = new csv_1.CSVLoader(itemBlob, {
                    column,
                    separator,
                });
                break;
            case 'application/epub+zip':
                loader = new EpubLoader_1.N8nEPubLoader(Buffer.from(bufferData));
                break;
            case 'application/vnd.openxmlformats-officedocument.wordprocessingml.document':
                loader = new docx_1.DocxLoader(itemBlob);
                break;
            case 'text/plain':
                loader = new text_1.TextLoader(itemBlob);
                break;
            case 'application/json':
                const pointers = this.context.getNodeParameter('pointers', itemIndex);
                const pointersArray = pointers.split(',').map((pointer) => pointer.trim());
                loader = new json_1.JSONLoader(itemBlob, pointersArray);
                break;
            default:
                throw new n8n_workflow_1.NodeOperationError(this.context.getNode(), `Unsupported mime type: ${mimeType}`);
        }
        const textSplitter = (await this.context.getInputConnectionData("ai_textSplitter", 0));
        const loadedDoc = textSplitter ? await loader.loadAndSplit(textSplitter) : await loader.load();
        docs.push(...loadedDoc);
        if (metadata) {
            docs.forEach((document) => {
                document.metadata = {
                    ...document.metadata,
                    ...metadata,
                };
            });
        }
        return docs;
    }
}
exports.N8nBinaryLoader = N8nBinaryLoader;
//# sourceMappingURL=N8nBinaryLoader.js.map